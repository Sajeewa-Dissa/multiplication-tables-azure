<!DOCTYPE html>
<html lang="en">
<head>
    <title>Modulo Multiplication Circle JSon</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="icon" href="favicon.ico" type="image/x-icon" />
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
    <script type="text/javascript" src="sharedscript.js"></script>
    <link rel="stylesheet" href="site.css" />
</head>
<body onLoad="JavaScript:setOnRefresh();">
    <form action="#" method="post">
    <div id="page-container">
        <header class="header">
            <img src="logo.png" alt="lab logo" class="logo">
            <h1>Modulo Multiplication Circle Using JSON and the Azure Cloud.</h1>
            <p>Geometric patterns formed by multiplication in modulo n, joining points along the circumference of a circle.</p>
        </header>
        <div class="wrapper">
            <div class="intro">
                <section id="textcontent">
                    <p class="firstpara">
                        When enumerating the multiplication times tables as lines in a circle, strange and beautiful patterns are formed.
                        For this exercise, we divide a circle's diameter into equi-distant points with the 9 o'clock position representing zero (by convention), and each point clockwise being a unit increment.
                        For any times table, the result is expressed as a series of lines joining each factor to its product. When we come full circle, we can continue the multiplication
                        by re-using the points via modulo division. A full explanation of this idea is cited in the YouTube link below.
                    </p>
                    <p>
                        This page is created in HTML using inline CSS and JavaScript with calls to <strong>Azure Functions and Cloud Services.</strong> The patterns are drawn on a canvas element, and the page includes
                            grid layouts.
                    </p>
                    <p class="lastpara">
                        <span><a href="https://github.com/Sajeewa-Dissa/multiplication-tables-azure" target="_blank">GitHub</a> the source code for this project is available here.</span><br />
                        <span><a href="https://sajeewa-dissa.github.io/multiplication-tables-js/index.html">JavaScript</a> the same functionality found here, but uses (more responsive) client-side JavaScript only.</span><br />
                        <span><a href="https://www.youtube.com/watch?v=qhbuKbxJsk8" target="_blank">YouTube Mathologer</a> the linked YouTube video was the inspiration for this webpage.</span><br />
                    </p>
                </section>
            </div>
            <div class="canvaswrap">
                    <canvas id="canvas" width="550" height="550">Your browser doesn't support the canvas element</canvas>
                    <p><span id="statusmsg"></span></p>
            </div>
            <div class="controls">
                <div>
                    <label class="subheading">Settings:</label>
                </div>
                <div class="buttoncontainer">
                    <input type="button" id="toggleBut" class="blueButtonLarge blueButton" value="Autoplay" />
                </div>
                <div id="controlgrid">
                    <div>
                        <p>Multiply by (1 to 100):</p>
                    </div>
                    <div>
                        <p><output id="multiplierOut" class="spanOutput"></output></p>
                    </div>
                    <div class="slidecontainer">
                        <input type="range" min="1" max="100" value="1" class="slider" id="myRange1"> <!--initial value 1-->
                    </div>
                    <div>
                        <p>Modulo n (1 to 200):</p>
                    </div>
                    <div>
                        <p><output id="moduloOut" class="spanOutput"></output></p>
                    </div>
                    <div class="slidecontainer">
                        <input type="range" min="1" max="200" value="200" class="slider" id="myRange2"> <!--initial value 200-->
                    </div>
                    <div>
                        <p>Radius (100 to 250):</p>
                    </div>
                    <div>
                        <p><output id="radiusOut" class="spanOutput"></output></p>
                    </div>
                    <div class="slidecontainer">
                        <input type="range" min="100" max="250" value="250" class="slider" id="myRange3"> <!--initial value 250-->
                    </div>
                    <div class="buttonsimcontainer">
                        <div class="blueButtonSimulator">
                            <a id="linktester" href="AzureTester.html">Test Azure</a>
                        </div>
                    </div>
                    <div>
                    </div>
                    <div class="radiogroupcontainer">
                        <label class="radiocontainer">
                            Azure JS Fn.
                            <input type="radio" id="js" checked="checked" name="rpctype">
                            <span class="checkmark"></span>
                        </label>
                        <label class="radiocontainer">
                            Azure C# Fn.
                            <input type="radio" id="cs" name="rpctype">
                            <span class="checkmark"></span>
                        </label>
                        <label class="radiocontainer">
                            Azure Cloud Svc.
                            <input type="radio" id="ws" name="rpctype">
                            <span class="checkmark"></span>
                        </label>
                    </div>
                </div>
            </div>
        </div>
        <div class="footer">
            <p>&#169;<small> Copyright 2019 Sajeewa Dissanayake</small></p>
        </div>
    </div>
        <script>
            //set DOM references for HTML elements
            var statusmsg = document.getElementById("statusmsg");
            var ctx = document.getElementById("canvas").getContext("2d");
            var slider1 = document.getElementById("myRange1");
            var slider2 = document.getElementById("myRange2");
            var slider3 = document.getElementById("myRange3");
            var output1 = document.getElementById("multiplierOut");
            var output2 = document.getElementById("moduloOut");
            var output3 = document.getElementById("radiusOut");
            var radiojs = document.getElementById("js");
            var radiocs = document.getElementById("cs");
            var radiows = document.getElementById("ws");
            var anchor = document.getElementById("linktester");

            //define circle centre, radius and other initial values
            var coords = [];
            var matrix = [];
            var multiple = 1;
            var mustCallCreateCoords; // boolean to decide on RPC call
            var mustCallCreateMatrix;
            var cumulativeCoordsRPC = 0
            var cumulativeMatrixRPC = 0
            var prevModulo = 0;
            var prevRadius = 0;
            var prevMultiplier = 0;
            var strstatusmsg = "";
            var strerrormsg = "";
            var initialstatusmsg = "Please note that remote calls have been limited to five sets per sec.";
            var initialRadius = slider3.value;
            var toggleBut = document.getElementById("toggleBut");
            var lasttimedrawcalled = 0;
            var playingslider = false;

            statusmsg.innerHTML = initialstatusmsg;
            output1.innerText = slider1.value;
            output2.innerText = slider2.value;
            output3.innerText = slider3.value;

            toggleBut.addEventListener("click", Start);

            //#region basic functionailty copied from related pure JavaScript demo project 

            anchor.addEventListener('click', function (event) {
                // Stop the link from redirecting
                event.preventDefault();
                var queryString = modifyQueryString(); //construct the params for the get request
                // Redirect instead with JavaScript
                window.location.href = anchor.href + queryString;
            }, false);

            slider1.oninput = function () { handleSliderUpdate(this, output1); }
            slider2.oninput = function () { handleSliderUpdate(this, output2); }
            slider3.oninput = function () { handleSliderUpdate(this, output3); }

            slider1.onchange = function () { handleSliderUpdateNow(this, output1); }
            slider2.onchange = function () { handleSliderUpdateNow(this, output2); }
            slider3.onchange = function () { handleSliderUpdateNow(this, output3); }

            //draw circle (outline only) using initial values above.
            drawHollowCircle(centreX, centreY, initialRadius);

            function drawHollowCircle(x0, y0, radius) {
                console.log("drawing hollow circle ");
                ctx.lineWidth = "1";
                ctx.strokeStyle = "lightgrey";
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.beginPath();
                ctx.arc(x0, y0, radius, 0, Math.PI * 2, true); // 2 Pi radians is a complete circle (note drawing arc starts from 3 o'clock position but this isn't an issue)
                ctx.stroke();
                ctx.closePath();
            }

            //reset slider and circle on page refresh
            function setOnRefresh() {
                resetControlsToStart();
            }

            function resetControlsToStart() {
                playingslider = false;
                toggleBut.removeEventListener("click", Stop);
                toggleBut.addEventListener("click", Start);
                toggleBut.value = "Autoplay";

                multiple = 1;
                slider1.value = multiple;
                output1.innerText = multiple;
                output2.innerText = slider2.value;
                output3.innerText = slider3.value;
                var radius = output3.innerText;
                drawHollowCircle(centreX, centreY, radius); //draw an empty circle only.
                //fadeOut(); //??

                if (document.querySelector('input[name="rpctype"]:checked') == null) { //make sure a default RPC method is selected.
                    radiojs.checked = true; //set this by default.
                }

                //show the initial info screen display message only on page refresh. Otherwise nothing.
                if (document.querySelector("span#statusmsg").firstChild.nodeValue != initialstatusmsg) {
                    statusmsg.innerHTML = "";
                }
                //remove any global error messages
                strerrormsg = "";
            }

            function handleSliderUpdate(slider, control) {
                if (slider.id == "myRange1") {             // if multiplier being changed
                    multiple = Number(slider.value);       // save this global variable for autoplay restart.
                }
                control.innerText = slider.value;
                // Call for drawing of circle but not immediately (higher priority event handlers exist).
                drawResults();
            }

            //#endregion

            function handleSliderUpdateNow(slider, control) {
                if (slider.id == "myRange1") {             // if multiplier being changed
                    multiple = Number(slider.value);       // save this global variable for autoplay restart.
                }
                control.innerText = slider.value;
                // Always call for immediate drawing of circle on slider change events (unless in autoplay mode).
                if (playingslider) {
                    drawResults();
                } else {
                    drawResultsNow();
                }
            }

            //a wrapper function to limit the number of RPC calls per second.
            //draw result immediately, but if previous call was less than 200ms ago, then do nothing.
            function drawResults() {
                //if autoplay is on, let it handle drawing of circles instead.
                if (playingslider) {
                    return;
                }

                var d = new Date();
                var timesinceprevcall = d.getTime() - lasttimedrawcalled;

                if (timesinceprevcall > 200) {
                    drawResultsNow();     
                } 
            }

            function drawResultsNow() {
                //This method is called by all relevant change handlers and always resets the arrays used to draw the circle, 
                //so there should be no lag causing drawing of circle using previous inputs.

                //form the params for the RPC call.
                var multiplierVal = slider1.value;
                var moduloVal = slider2.value;
                var radiusVal = slider3.value;
                var rpcval = document.querySelector("input[name=rpctype]:checked").id;

                var d = new Date();
                var starttime = d.getTime();

                lasttimedrawcalled = d.getTime(); // set this value to govern too many remote calls per second.
                var coordspromise;
                var matrixpromise;
                var mustUpdateDrawing;
                
                //check which of the two methods have to be called (assume both by default).
                mustCallCreateCoords = true; // boolean to decide on RPC call
                mustCallCreateMatrix = true; // ditto
                if (radiusVal == prevRadius && moduloVal == prevModulo) {          // if these values are unchanged, the pattern circular coords are unchanged.
                    mustCallCreateCoords = false;
                }
                if (multiplierVal == prevMultiplier && moduloVal == prevModulo) {  // if these values are unchanged, the multiplication matrix is unchanged.
                    mustCallCreateMatrix = false;
                }

                mustUpdateDrawing = mustCallCreateCoords || mustCallCreateMatrix;

                if (!mustUpdateDrawing) { //we don't need to do anything more
                    return;
                }

                //Call any required methods to prepare for drawing of patterns and do so using promises.
                if (mustCallCreateCoords) {
                    coordspromise = prepareApiCallRtnPromise(multiplierVal, moduloVal, radiusVal, rpcval, "createCoords", starttime);
                } else {
                    coordspromise = Promise.resolve(""); // a dummy promise resolved successfully.
                }
                    
                if (mustCallCreateMatrix) {
                    matrixpromise = prepareApiCallRtnPromise(multiplierVal, moduloVal, radiusVal, rpcval, "createMatrix", starttime);
                } else {
                    matrixpromise = Promise.resolve(""); // a dummy promise resolved successfully.
                }

                //Handle when both promises resolved successfully or when they fail.
                Promise.all([coordspromise, matrixpromise])
                    .then(values =>
                        prepDrawPattern(values, multiplierVal, moduloVal, radiusVal))
                    .catch(error => {
                        handleError(error)
                    });
            }

            //we have retuned with resolved promises. Now update the arrays amd draw the pattern.
            function prepDrawPattern(resultsarray, thismultiplier, thismodulo, thisradius) {
                var starttime;
                var httpstatuscheck = 200;
                var mustUpdateDrawing;

                //maybe there is no change to anything - so check if anything has changed.
                mustUpdateDrawing = mustCallCreateCoords || mustCallCreateMatrix;
                if (!mustUpdateDrawing) {
                    return;  //nothing to draw.
                }

                if (httpstatuscheck == 200 && mustCallCreateCoords) {
                    starttime = resultsarray[0].stime;
                    httpstatuscheck = updateCoordsArray(resultsarray[0].rsp);
                }

                if (httpstatuscheck == 200 && mustCallCreateMatrix) {
                    starttime = resultsarray[1].stime;
                    httpstatuscheck = updateMatrixArray(resultsarray[1].rsp);
                }

                if (httpstatuscheck == 200) {
                    //draw the circle pattern for the current values and then save this as previous settings.
                    doDrawOnCanvas(thisradius, httpstatuscheck, starttime);
                    prevMultiplier = thismultiplier;
                    prevRadius = thisradius;
                    prevModulo = thismodulo;
                    cycleForAutoplay();
                }
            }

            function updateCoordsArray(xmlHttp) {
                cumulativeCoordsRPC += 1;
                coords = getJsonArrayFromXmlOrString(xmlHttp.response);//set the array
                return Number(xmlHttp.status);                         // check for status 200
            }

            function updateMatrixArray(xmlHttp) {
                cumulativeMatrixRPC += 1;
                matrix = getJsonArrayFromXmlOrString(xmlHttp.response);//set the array
                return Number(xmlHttp.status);                         // check for status 200
            }
            
            function doDrawOnCanvas(radius, status, starttime) {   //we call this function to draw circle with current global array settings etc.
                drawHollowCircle(centreX, centreY, radius);

                if (status == 200) {
                    drawPattern();
                    //Update communication info on screen
                    showStatusInfo(status, starttime);
                }
            }

            function drawPattern() {
                //avoid pattern being drawn at end of autoplay (return is async after slider is reset).
                if (coords.length != matrix.length) {
                    console.log("todo array mismatch") ;
                    return;
                }

                ctx.lineWidth = "1";
                ctx.strokeStyle = "wheat";
                ctx.beginPath();
                for (var i = 0; i < matrix.length; i++) {
                    var startX = coords[matrix[i][0]][0];
                    var startY = coords[matrix[i][0]][1];
                    var endX = coords[matrix[i][1]][0];
                    var endY = coords[matrix[i][1]][1];
                    addLineSubPath(ctx, startX, startY, endX, endY);
                    function addLineSubPath(ctx, sX, sY, eX, eY) {
                        ctx.moveTo(sX, sY);
                        ctx.lineTo(eX, eY);
                        ctx.stroke();
                    }
                }
                ctx.closePath();
                console.log("pattern drawn ");
            }

            function handleError(err) {
                strerrormsg = "Error.  Status:" + err.status + " " + err.statusText + " " + err.moreinfo;
                strerrormsg += ". Please try an alternative cloud service instead."
                statusmsg.innerHTML = strerrormsg;

                var radius = output3.innerText;
                drawHollowCircle(centreX, centreY, radius);
                Stop(); // stop if in autoplay mode
            }

            function showStatusInfo(status, starttime) {
                var d = new Date();
                var duration = d.getTime() - starttime;
                strstatusmsg = "Returned in " + duration + " ms. Status " + status;
                strstatusmsg += ". Total RPCs:" + (cumulativeCoordsRPC).toString() + " + " + (cumulativeMatrixRPC).toString();
                statusmsg.innerHTML = strstatusmsg;
            }

            //wrapper function to repeat the circle drawing method periodically (only called when the response returned and promises are resolved).
            function cycleForAutoplay() {

                if (!playingslider) {  //check we are in autoplay mode
                    return;
                }

                // Call the playMultiplierSlider method when we reach between 700 ms and 750 ms since last request to draw circle.
                // However, if previous remote call response was delayed more than 750 ms from the request (usually happens on initial requests),
                // then display the current (delayed) circle pattern and info message for the exact amount of delay up to a max 2000 ms!
                var nextcall;
                var d = new Date();
                var timesinceprevdraw = d.getTime() - lasttimedrawcalled;

                if (timesinceprevdraw > 750) {
                    nextcall = Math.min(2000, timesinceprevdraw); //next call between 2000 and 750 ms.
                } else {
                    nextcall = Math.max(700, (Math.min(750, 750 - timesinceprevdraw)));
                }
                console.log("next call " + nextcall.toString() + " " + d.toTimeString());
                setTimeout(function () { playMultiplierSlider() }, nextcall);
            }

            function playMultiplierSlider() {

                if (!playingslider || (multiple > 99)) { //check we are still in autoplay or have reached the end
                    Stop();
                    return;
                }

                multiple += 1;
                slider1.value = multiple;
                output1.innerText = multiple;
                drawResultsNow();

                if (multiple > 99) {  /*check again if we have reached the end of autoplay.*/
                    Stop();
                }
            }

            function Start() {
                toggleBut.removeEventListener("click", Start);
                toggleBut.addEventListener("click", Stop);
                toggleBut.value = "Stop";

                playingslider = true;
                playMultiplierSlider();
            }

            function Stop() {
                playingslider = false;
                if (multiple > 99) {        //if end of range has been reached, reset slider etc.
                    setTimeout(function () { resetControlsToStart(); }, 2000) //wait until async calls have returned and drawn circle.
                    return;
                }

                toggleBut.removeEventListener("click", Stop);
                toggleBut.addEventListener("click", Start);
                toggleBut.value = "Autoplay";
            }

            function modifyQueryString() {
                // get all querys tring params
                const amp = "&";
                var qstring = "?";
                qstring += "multiple=" + output1.value.toString() + amp;
                qstring += "modulus=" + output2.value.toString() + amp;
                qstring += "radius=" + output3.value + amp;
                qstring += "rpc=" + document.querySelector('input[name="rpctype"]:checked').id;
                return qstring;
            }

            //parse the xml or JSON string response and return it as a pure JSON array.
            function getJsonArrayFromXmlOrString(input) {
                var str = input.substring(input.indexOf("[[") + 1);
                str = str.substring(0, str.lastIndexOf("]]") + 1);
                var array = eval('[' + str + ']');
                return array;
            }

        </script>

    </form>
</body>
</html>
